# 数字描述

### 负值

在我们的现代10进制计数系统中，我们通过在数字前放置一个减号（-）指定一个负数。当使用二进制时我们需要使用一个不同的系统来指定负数。

在现代硬件中只有一种方案被普遍使用，但是C99为负数描述定义了三个可接受的方法。

#### 符号位

最直接的方法是简单地用数字的一位表示负值或正值，这取决于它是否被设置。

这与数学方法中有+和-相似。这是相当合理的，一些原始的计算机确实以这种方式表示负数。但使用二进制数字提供了一些其他的可能性，使硬件设计人员的工作更轻松。

但是，请注意值0现在有两个等效值;一个符号位被设置，一个没有。有时这些值分别称为+0和-0。

#### 反码（One's Complement）

反码对正数使用了***非***运算来表示负数。所以，例如值-90（0x5A）被表示为~01011010=10100101[^4]

使用这种方式的最大优势在于将一个正数与负数相加不需要特殊逻辑，除了剩余的任何左移进位必须添加回到最终值。

### 表2.15 反码加法

| **十进制** | **二进制**        | **操作** |
| ------- | -------------- | ------ |
| -90     | 10100101       | +      |
| 100     | 01100100       |        |
| ---     | --------       |        |
| 10      | $$^1$$00001001 | 9      |
|         | 00001010       | 10     |

如果你一位一位地加，最终你会发现有一个进位（上面突出部分）。通过把这个加回到原来的结果上最终我们得到了正确值，10。

同样，我们仍然有2个零被描述的问题。而且现代计算机不用反码，很大程度上是因为还有更好的方法。

#### 补码（Two's Complement）

除了负数表示方法需要加1而且我们丢弃了所有的左移进位，补码就和反码一样。继续之前的例子，-90应该表示为~01011010+1=10100101+1=10100110。

这意味着可以表示的数字有一点稍微的奇对称；比如一个8位整数我们有$$2^8=256$$种可能数值；使用符号位描述方法我们可以表示-127到127但是使用补码描述方法我们可以表示-127到128。这是因为我们解决了有两个零的问题；『负零』是（~00000000+1）=（11111111+1）=00000000（注意舍弃了进位）。

### 表2.16 补码加法

| **十进制** | **二进制**  | **操作** |
| ------- | -------- | :----- |
| -90     | 10100110 | +      |
| 100     | 01100100 |        |
| ---     | -------- |        |
| 10      | 00001010 | <br>   |

你可以看到，实现二进制补码硬件，设计师只需要为加法电路提供逻辑;减法可以通过二进制补码对要减去的值求反，然后加上新值。

类似的，你可以通过重复加法实现乘法，以及重复减法实现除法。

结果补码可以将所有简单数学计算化简到加法！

所以现代计算机都使用补码描述法。

##### 符号扩展

由于补码的咯吱，当增加有符号数值的大小时，附加位被符号扩展很重要；也就是说，从现有值的顶部位复制。

例如，32位整型-10用补码形式表示为11111111111111111111111111110110。如果有人把它转换成64位长度的长整型，我们需要确保附加的32位被设为1以维持与原来相同的符号。

由于二进制补码，得以取出现值的顶部位，并用这个值替换所有添加的位。这个过程称为***符号扩展***，通常由编译器在由语言标准定义的情况下处理，处理器通常提供特殊指令以获取值并将其符号扩展为更大的值。

### 浮点

到目前为止，我们只讨论整型或整数;可以表示小数数值的数字的类称为***浮点***。

为了创造小数，我们需要一些方法在二进制中表示小数的概念。最常见的方案被称为***IEEE-754 浮点标准***应为这个标准由电气与电子工程师学会（Institute of Electric and Electronics Engineers）发布。这个方案概念上很简单，有点类似于“科学记数法”。

在科学记数法中，值123.45通常表示为$$1.2345\times10^2$$。我们称1.2345为***尾数***或***有效数字***，10是***基数***，2是***指数***。

在IEEE浮点模型中，我们把可获得的二进制位拆分开来表示一个小数的符号，尾数和指数。十进制数被表示为符号 $$\times$$ 有效数字$$\times$$<sup>指数</sup>。

符号位等于1或-1。由于我们工作在二进制，我们总是有隐含的基数2。

浮点值有不同的宽度 - 下面我们只讨论一个32位的值。更多的位提供更高的精度。

### 表2.17 IEEE浮点

| **符号** | **指数**   | **有效数字/尾数**             |
| ------ | -------- | ----------------------- |
| S      | EEEEEEEE | MMMMMMMMMMMMMMMMMMMMMMM |

另外一个重要因素就是指数的***偏差***。指数需要能够表示正值和负值，因此从指数中减去127的隐含值。例如，指数0具有指数字段127，128指代1，126指代-1。

有效数学的每一位为我们可以表示的数值增加一些更高的精度。试想一下值198765的用科学计数法来表示。我们可以写作$$1.98765\times10^6$$，这对应于下面的表示。

### 表2.18 198765的科学计数法

| **$$10^0$$** | **.** | $$10^{-1}$$ | **$$10^{-2}$$** | **$$10^{-3}$$** | **$$10^{-4}$$** | **$$10^{-5}$$** |
| :----------: | ----- | :---------: | :-------------: | :-------------: | :-------------: | :-------------: |
|      1       | .     |      9      |        8        |        7        |        6        |        5        |

每一个增加的数位是的我们能够表达更大范围的小数数值。在十进制中，小数点后的每一位将数字精度提高10倍。例如，我们可以用小数点后一位可以表示0.0到0.9（10个数值），用两位可以表示0.00到0.99（100个数值），等等。在二进制中，每增加一位不会使精度提高10倍，只会提高2倍精度，如下表所说明的。这意味着我们的二进制表示不总是以直接的方式映射到十进制表示。

### 表2.19 二进制中的有效数字

| **$$2^0$$** | **.** | **$$2^{-1}$$** | **$$2^{-2}$$** | **$$2^{-3}$$** | **$$2^{-4}$$** | **$$2^{-5}$$** |
| ----------- | ----- | -------------- | -------------- | -------------- | -------------- | -------------- |
| 1           | .     | 1/2            | 1/4            | 1/8            | 1/16           | 1/32           |
| 1           | .     | 0.5            | 0.25           | 0.125          | 0.0625         | 0.03125        |

只有一位精度时，我们的分数精度不是很大；这个分数不是0就是0.5。如果我们精度上增加一位，现在小数数值是0，0.25，0.5，0.75中的一个。再加上一位精度，我们可以表达这些数值0，0.125，0.25，0.375，0.5，0.625，0.75，0.875。

增加位数使得我们得到越来越大的精度。然而，由于数字的范围是无限的，我们将永远不会有足够的位数来表示***任意***数值。

比如说，如果我们有两位精度，而我们要表示0.3，我们只好说它最接近0.25；显然，这对大多数应用来说说不够的。用22位有效数字，我们可以得到一个好的多的解，但是对于大多数应用来说这还是不够。一个double值将有效数字位数增加到了52（它也增加了指数的范围）。有些硬件有84位的浮点，有64位的有效数字。64位提供了一个极好的精确度，应该能够满足绝大多数应用程序的需求（这足以表示小于原子尺寸的长度嘛？）

### 例2.3 Float对比Double

```c
  1  $ cat float.c
    #include <stdio.h>
    
  5 int main(void)
    {
            float a = 0.45;
            float b = 8.0;
    
 10         double ad = 0.45;
            double bd = 8.0;
    
            printf("float+float, 6dp    : %f\n", a+b);
            printf("double+double, 6dp  : %f\n", ad+bd);
 15         printf("float+float, 20dp   : %10.20f\n", a+b);
            printf("dobule+double, 20dp : %10.20f\n", ad+bd);
    
            return 0;
    }
 20 
    $ gcc -o float float.c
    
    $ ./float
    float+float, 6dp    : 8.450000
 25 double+double, 6dp  : 8.450000
    float+float, 20dp   : 8.44999998807907104492
    dobule+double, 20dp : 8.44999999999999928946
    
    $ python
 30 Python 2.4.4 (#2, Oct 20 2006, 00:23:25)
    [GCC 4.1.2 20061015 (prerelease) (Debian 4.1.1-16.1)] on linux2
    Type "help", "copyright", "credits" or "license" for more information.
    >>> 8.0 + 0.45
    8.4499999999999993
 35 
```

上面说明了一个实际的例子。注意，对于由printf给出的默认为6个小数位精度，两个答案是相同的，因为它们被正确地舍入。然而，当需要结果有更大的精确度时，在这个例子中，20位小数，我们可以看到结果开始产生分歧。使用double的代码有更精确的结果，但是它仍然不是完全正确的。我们也可以看到程序员没有明确处理浮点值仍然有变量的精度问题！

#### 规范化数值

在科学计数法中，我们可以用许多不同的方式表示一个数值。例如,$$10023\times10^1=1002.3\times10^1=100.23\times10^2$$。我们因此定义***规范化***版本为***1/基数<=有效数字<1***。在二进制中，这确保了有效位数的最左边的位总是1。知道这一点，我们可以通过制定一个标准：有效数字的最左边为隐含的1，以此来获得额外的精度。

### 表2.20 规范化0.375的举例

| **$$2^0$$** | **.** | **$$2^{-1}$$** | **$$2^{-2}$$** | **$$2^{-3}$$** | **$$2^{-4}$$** | **$$2^{-5}$$** | **指数** | **计算**                   |
| ----------- | ----- | -------------- | -------------- | -------------- | -------------- | -------------- | ------ | ------------------------ |
| 0           | .     | 0              | 1              | 1              | 0              | 0              | 2^0    | (0.25+0.125) × 1 = 0.375 |
| 0           | .     | 1              | 1              | 0              | 0              | 0              | 2^-1   | (0.5+0.25)×.5=0.375      |
| 1           | .     | 1              | 0              | 0              | 0              | 0              | 2^-2   | (1+0.5)×0.25=0.375       |

如上所述，我们可以通过向上移动位来使值标准化，只要我们通过增加指数进行补偿即可。

#### 标准化小技巧

一个程序员面临的常见问题是如何找到位域中的第一个被设置的位。比方说位字段是0100；从右边开始第一个设置位是位2（按照传统，从零开始）。

找到这个值的标准方法是向右移位，检查最高位是否为1，并终止或重复。这是一个缓慢的过程;如果位域长为64位并且只有最后一位被设置，则必须遍历所有前面的63位！

然而，如果这个位字段是一个浮点数的有效数字，而且我们要对他进行标准化，则指数值能够告诉我们它会被移位多少次。对一个数字标准化的过程通常内置在处理器的浮点硬件单元中，所有运行的非常快；通常比反复移位和检查操作快的多。

下面的示例程序展示了在安腾处理器上的两种寻找第一个设置位的方法。安腾处理器，就想大多数服务器处理器，支持80位的扩展浮点类型，它有64位的有效数字。这意味着long double类型的有效数字中正好放进了一个无符号long（unsigned long）类型。当数值被加载时，它被标准化了，并且因此通过读取指数值（减去16位偏差），我们可以看到它被移动了多远。

### 例2.4 寻找第一个设置位的程序

```c
  1 #include <stdio.h>
    
    int main(void)
  5 {
    	//  in binary = 1000 0000 0000 0000
    	//  bit num     5432 1098 7654 3210
    	int i = 0x8000;
    	int count = 0;
 10 	while ( !(i & 0x1) ) {
    		count ++;
    		i = i >> 1;
    	}
    	printf("First non-zero (slow) is %d\n", count);
 15 
    	// this value is normalised when it is loaded
    	long double d = 0x8000UL;
    	long exp;
    
 20 	// Itanium "get floating point exponent" instruction
    	asm ("getf.exp %0=%1" : "=r"(exp) : "f"(d));
    
    	// note exponent include bias
    	printf("The first non-zero (fast) is %d\n", exp - 65535);
 25 
    }
    
                  
```

#### 结合起来

在下面的示例代码中，我们抽吸了一个浮点数的各个部分，然后打印出它所表示的值。这只能在IEEE格式的32位浮点数值上有效；然而，通常大多数架构都有float类型。

### 例2.5 研究Float 

```c
  1 #include <stdio.h>
    #include <string.h>
    #include <stdlib.h>
  5 
    /* return 2^n */
    int two_to_pos(int n)
    {
    	if (n == 0)
 10 		return 1;
    	return 2 * two_to_pos(n - 1);
    }
    
    double two_to_neg(int n)
 15 {
    	if (n == 0)
    		return 1;
    	return 1.0 / (two_to_pos(abs(n)));
    }
 20 
    double two_to(int n)
    {
    	if (n >= 0)
    		return two_to_pos(n);
 25 	if (n < 0)
    		return two_to_neg(n);
    	return 0;
    }
    
 30 /* Go through some memory "m" which is the 24 bit significand of a
       floating point number.  We work "backwards" from the bits
       furthest on the right, for no particular reason. */
    double calc_float(int m, int bit)
    {
 35 	/* 23 bits; this terminates recursion */
    	if (bit > 23)
    		return 0;
    
    	/* if the bit is set, it represents the value 1/2^bit */
 40 	if ((m >> bit) & 1)
    		return 1.0L/two_to(23 - bit) + calc_float(m, bit + 1);
    
    	/* otherwise go to the next bit */
    	return calc_float(m, bit + 1);
 45 }
    
    int main(int argc, char *argv[])
    {
    	float f;
 50 	int m,i,sign,exponent,significand;
    
    	if (argc != 2)
    	{
    		printf("usage: float 123.456\n");
 55 		exit(1);
    	}
    
    	if (sscanf(argv[1], "%f", &f) != 1)
    	{
 60 		printf("invalid input\n");
    		exit(1);
    	}
    
    	/* We need to "fool" the compiler, as if we start to use casts
 65 	   (e.g. (int)f) it will actually do a conversion for us.  We
    	   want access to the raw bits, so we just copy it into a same
    	   sized variable. */
    	memcpy(&m, &f, 4);
    
 70 	/* The sign bit is the first bit */
    	sign = (m >> 31) & 0x1;
    
    	/* Exponent is 8 bits following the sign bit */
    	exponent = ((m >> 23) & 0xFF) - 127;
 75 
    	/* Significand fills out the float, the first bit is implied
    	   to be 1, hence the 24 bit OR value below. */
    	significand = (m & 0x7FFFFF) | 0x800000;
    
 80 	/* print out a power representation */
    	printf("%f = %d * (", f, sign ? -1 : 1);
    	for(i = 23 ; i >= 0 ; i--)
    	{
    		if ((significand >> i) & 1)
 85 			printf("%s1/2^%d", (i == 23) ? "" : " + ",
    			       23-i);
    	}
    	printf(") * 2^%d\n", exponent);
    
 90 	/* print out a fractional representation */
    	printf("%f = %d * (", f, sign ? -1 : 1);
    	for(i = 23 ; i >= 0 ; i--)
    	{
    		if ((significand >> i) & 1)
 95 			printf("%s1/%d", (i == 23) ? "" : " + ",
    			       (int)two_to(23-i));
    	}
    	printf(") * 2^%d\n", exponent);
    
100 	/* convert this into decimal and print it out */
    	printf("%f = %d * %.12g * %f\n",
    	       f,
    	       (sign ? -1 : 1),
    	       calc_float(significand, 0),
105 	       two_to(exponent));
    
    	/* do the math this time */
    	printf("%f = %.12g\n",
    	       f,
110 	       (sign ? -1 : 1) *
    	       calc_float(significand, 0) *
    	       two_to(exponent)
    		);
    
115 	return 0;
    }
```

值为8.45的样本输出，我们之前研究过，如下所示。

### 例2.6 8.45的分析

```bash
$ ./float 8.45
8.450000 = 1 * (1/2^0 + 1/2^5 + 1/2^6 + 1/2^7 + 1/2^10 + 1/2^11 + 1/2^14 + 1/2^15 + 1/2^18 + 1/2^19 + 1/2^22 + 1/2^23) * 2^3
8.450000 = 1 * (1/1 + 1/32 + 1/64 + 1/128 + 1/1024 + 1/2048 + 1/16384 + 1/32768 + 1/262144 + 1/524288 + 1/4194304 + 1/8388608) * 2^3
8.450000 = 1 * 1.05624997616 * 8.000000
8.450000 = 8.44999980927
```

从这个例子中，我们可以了解到误差是怎么悄悄进入浮点数里面的。

---

[^4]: ~ 操作符是C语言中对数值进行逻辑***非***运算的操作符。它偶尔也被称作反码操作符，原因现在很明显！

