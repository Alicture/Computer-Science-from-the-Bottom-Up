

# 类型

作为程序员，我们熟悉使用变量来表示内存的一块区域以存储数值。在***类型化的***语言中，比如C，每一个变量都必须用***类型***声明。类型告诉编译器我们想要在变量中存储什么；然后编译器可以为这个使用分配足够的空间并且检查程序员是否违反了类型的规则。在下面的例子里，我们可以看到为常见类型的变量分配空间的示例。

### 图2.2 类型

![](http://ww1.sinaimg.cn/large/76731d17gy1fcfnho77mxj20hc0itmx3)

C99标准只有意提到了为C定义的每种类型的最小可能大小。这是因为在不同的处理器架构和操作系统之间类型的最优大小差异可能是巨大的。

为了彻底的安全程序员永远不能为任何变量指定大小，但是一个功能正常的系统明显需要在系统使用类型的大小上达成共识。每个架构和操作系统都遵照***应用二进制接口***或***ABI***。一个系统的ABI包含C语言标准与底层硬件及操作系统的需求之间的细节。一个ABI是为一个特定的处理器和操作系统组合编写的。

### 表2.13 标准整数类型及大小

| **类型**    | **C99 最小大小 (bits)** | **通常大小 (32位架构)** |
| --------- | ------------------- | ---------------- |
| char      | 8                   | 8                |
| short     | 16                  | 16               |
| int       | 16                  | 32               |
| long      | 32                  | 32               |
| long long | 64                  | 64               |
| Pointers  | 依赖于实现               | 32               |

通过上面的表我们可以看见和标准相比唯一的区别在于int通常是一个32位数量，是C99要求的严格最小大小16位的两倍。

指针其实只是一个地址（即，他们的值是一个地址因此『指向』内存中的其他地方）所以一个指针类型需要足够的大小使其能够为系统中的任何内存寻址。

### 64位

64位计算的入门是一个会导致困惑的地方。这意味着处理器能够处理寻址64位长度（具体地说，寄存器宽度是64位；这个话题我们会在[第三章 ，计算机架构](/chapter3/section3.1.html)中讨论）。

首先这意味着所有的指针都需要64位宽这样他们才能够表示系统中任何可能的地址。然而，之后系统实现者必须决定其他类型的大小。两只常见模型被广泛使用，如下面所展示。

### 表2.14 标准纯量类型和大小

| **类型**    | **C99最小大小 (bits)** | **通常大小(LP64)** | **通常大小(Windows)** |
| --------- | ------------------ | -------------- | ----------------- |
| char      | 8                  | 8              | 8                 |
| short     | 16                 | 16             | 16                |
| int       | 16                 | 32             | 32                |
| long      | 32                 | 64             | 32                |
| long long | 64                 | 64             | 64                |
| Pointers  | 依赖于实现              | 64             | 64                |

你们能看到在LP64（长指针-64（long-pointer64））模型中long数值被定义为64位宽。这与我们先前展示的32位模型不一样。LP64模型在UNIX系统中被广泛使用。

在其他模型中，long仍然是一个32位的数值。这维持了与32位代码的最大兼容性。这种模型在64位Windows系统中使用。

为什么int类型的大小在两个模型中都没有增长到64位，这是有原因的。考虑到如果int类型的大小被增加到64位，程序员将会无法获得32位的变量。唯一的可能就是重新定义short类型为一个更大的32位类型。

64位的变量是如此之大，通常不需要来表示许多变量。例如，循环很少重复次数大到放不进32位变量中（4294967296次！）。图像通常表示为，每个红色，绿色和蓝色值8位，额外信息使用一个额外的8位，一共32位来表示。结果许多情况下，使用一个64位变量会浪费至少头32位（如果不是更多的话）。不只是这样，一个整型数组的大小现在也翻了一番了。这意味这程序为了不存在的改进现在占用了更多系统内存（并且因此占用更多缓存；在[第三章，计算机架构](/chapter3/section3.1.html)中详细讨论）。因为同样的原因，Windows选择保持他们的long数值为32位；由于大多数Windows API最初编写是为了在32位系统上使用long变量，因此不需要额外的位，这会在系统中节省大量的浪费空间，而无需重新编写所有的API。

如果我们考虑所提出的替代，其中short被重新定义为32位变量;在64位系统上工作的程序员可以将其用于已知的变量，这些变量被限制为较小的值。然而，当移回到32位系统时，它们的相同短变量现在只有16位长，这是更容易溢出的值（65536）。

通过让程序员在需要更大的变量时知道他们将需要在可移植性问题和浪费二进制空间方面达到平衡。

### 类型限定符

C标准也谈到了一些变量类型的限定符。例如const表示一个变量将永远不能从其初值进行修改，volatile暗示编译器这个值可能会在程序执行流程之外改变，所以编译器要小心，不要以任何方式对他进行重新访问。

signed和unsigned可能是两个最重要的限定符；他们表明了一个变量是否可以携带一个负值。我们在下面更详细地研究这个。

限定符都旨在传递关于变量如何用于编译器的额外信息。这意味着两件事：编译器可以检查你是否违反了自己的规则（例如写入const值），并且可以根据额外的信息（在后续章节中进行研究）进行优化。

### 标准类型

C99意识到对所有规则，大小和可移植性的关注很快会变得非常令人困惑。为了提供帮助，它提供了一系列特殊类型，他们可以指定一个变量的确切特性。这些在``<stdint.h>``中被定义，它们有着``qtypes_t``的形式，其中q是一个限定符，type是基础类型，s是单位为比特位的宽度，_t是一个扩展让你知道你正在使用C99定义的类型。

例如，``uint8_t``是一个8位宽度的无符号整型。许多其他的类型都被定义了；完整列表在C99 17.8中详细说明或者（更加隐晦地）在头文件中[^3]。

由系统来实现C99标准，通过将他们在目标系统上映射到合适大小的类型给你提供这些类型；在Linux中这些头文件由系统库提供。

### 运作中的类型

在下面[例2.2，举例当类型不相符时的警告](#warning)中我们会看到一个例子，其说明了：类型如何对一个变量约束有效操作，而当变量被错误使用时编译器又是如何使用这些信息来警告。在这段代码中，我们首先将一个整型数值指派给一个字符型变量。应为字符型变量更小，我们失去了整型数值的正确值。再往下走，我们尝试为我们指定为整数的内存分配一个指针。这个操作可以进行；但是这不安全。第一个例子在一台32位奔腾机器上运行，并且返回了正确的数值。然而，如你所见，在第二个例子中，在一台64位安腾机器上指针长为64位（8字节），但是一个整型只有4字节的长度。显然，4个字节装不下8个字节！我们可以尝试通过在赋值之前***转换***值来”欺骗“编译器;注意，在这种情况下，我们通过无视编译器的警告而变换类型搬起石头砸了自己的脚，因为较小的变量无法装下来自指针的所有信息所以我们最终的得到了一个无效的地址。

<span id="warning">

### 例2.2 举例当类型不相符时的警告

```c
  1 /*
     * types.c
     */
    
  5 #include <stdio.h>
    #include <stdint.h>
    
    int main(void)
    {
 10 	char a;
    	char *p = "hello";
    
    	int i;
    
 15 	// moving a larger variable into a smaller one
    	i = 0x12341234;
    	a = i;
    	i = a;
    	printf("i is %d\n", i);
 20 
    	// moving a pointer into an integer
    	printf("p is %p\n", p);
    	i = p;
    	// "fooling" with casts
 25 	i = (int)p;
    	p = (char*)i;
    	printf("p is %p\n", p);
    
    	return 0;
 30 }
```

```bash
  1 $ uname -m
    i686
    
    $ gcc -Wall -o types types.c
  5 types.c: In function 'main':
    types.c:19: warning: assignment makes integer from pointer without a cast
    
    $ ./types
    i is 52
 10 p is 0x80484e8
    p is 0x80484e8
    
    $ uname -m
    ia64
 15 
    $ gcc -Wall  -o types types.c
    types.c: In function 'main':
    types.c:19: warning: assignment makes integer from pointer without a cast
    types.c:21: warning: cast from pointer to integer of different size
 20 types.c:22: warning: cast to pointer from integer of different size
    
    $ ./types
    i is 52
    p is 0x40000000000009e0
 25 p is 0x9e0
```

---

[^3]: 注意C99也有对于printf的可移植性帮助。在<inttypes.h>中PRI宏指令可以用作特定大小类型的限定符。详情见标准或者拆开头文件。

