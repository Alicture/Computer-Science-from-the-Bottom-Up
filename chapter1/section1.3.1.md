## The Shell

Shell是与操作系统交互的门户。它也许是bash，zsh，csh或其他的许多shell。他们本质上都只有一个主要任务——让你能够去执行程序（等之后我们讲到操作系统内部的时候你将会开始认识到shell究竟是怎么做到这些的）。

但是shell能做更多事而不仅仅让你能够执行程序。他们有能够重定向文件的强大能力，使你能够同时执行多个程序以及编写完整的程序。这些都回到了***万物皆文件***这句话。

### 重定向

通常我们不想要在[文件描述符小节](/chapter1/section1.3.html#file-descriptors)中提到的标准文件描述符指向他们预设的地方。例如。你也许想要抓取一个程序的所有输出到一个磁盘上的文件，或者，让它从你之前准备的文件中读取命令。另一个有用的任务可以是将一个程序的输出传到另一个程序的输入。和操作系统相结合，shell使得这一切变得便利得多。

### 表1.2 标准Shell重定向功能

| 名称       | 指令                                | 描述                                       | 举例                      |
| -------- | :-------------------------------- | ---------------------------------------- | ----------------------- |
| 重定向到一个文件 | `> filename`                      | 讲标准输出的所有输出取出然后放进`filename`。注意，使用`>>` 将会追加到文件，而不是覆写它。 | `ls > filename`         |
| 从一个文件读取  | `< filename`                      | 将文件的所有数据复制到程序的标准输入。                      | `echo < filename`       |
| 管道       | <code>program1 \| program2</code> | 获取`program1`标准输出的一切然后传递到`program2`的标准输入  | <code>ls \| more</code> |

### pipe的实现

ls | more的实现只是抽象之力量的另一个例子。这里本质上发生的不是将标准输出的文件描述符与一些底层设备相联（比如控制台，对终端输出），而是描述符被指向了一个由内核提供的内存缓冲器，其通常被称为一个***管道(pipe)***。这里的花招是，另一个进程可以将它的标准输入与同一个缓冲器的另一端相连然后能够高效地获取另一个进程的输出。这在[图1.4，"工作中的一个pipe"](#pipe-in-action)中被说明。

### 图1.4 工作中的一个pipe

<span id="pipe-in-action"></span>

![](http://ww1.sinaimg.cn/large/76731d17gy1fc6o9rdcqxj20ni0ao746.jpg)

pipe是将两个进程连接起来的一个内存缓冲器。文件描述符指向一个pipe对象，排空（通过一个read）发送给它（通过一个write）的被缓冲数据。

对pipe的写入会被内核储存直到相对应的另一端的读操作排空缓冲区。这是一个非常~~牛逼~~强大的概念而且这是类UNIX操作系统中***进程间通讯***（aka:IPC）的一种基本形式。pipe不只是允许数据传输；它可以作为一个信号通道。如果一个进程读一个空的pipe，它将被默认阻塞或进入休眠直到有数据可以获取（这将在[第五章，进程](/chapter5/)进行更深层次的探讨）。因此两个进程可以通过仅仅写一个字节的数据在采取某些操作时使用一个pipe进行通信；确切的数据并不太重要，仅仅是任何数据在pipe中存在就可以表示一个信息。举个例子，一个进程要求另一个进程打印一个文件——这会花些时间。这两个进程也许会在他们之间设置一个pipe，请求进程在空pipe上进行一个read；管道是空的，调用阻塞且进程不再继续。一旦打印完成，另一个进程可以把消息写入pipe，这高效地唤起了请求进程并且标志着工作完成。

允许进程在相互间像这样传递数据触发了另一个UNIX格言，小工具只做一件事，把这些小工具链接起来就能获得单一庞大的工具通常不具有的灵活性。