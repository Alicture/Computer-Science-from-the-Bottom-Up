# 文件描述符

<span id="file-descriptors">

UNIX程序员首先要知道的就是每个正在运行的程序都始于三个已经打开的文件：

### 表1.1 Unix提供的标准文件

| **表述的名称**      | **缩写** | **文件数** | **描述**                      |
| -------------- | ------ | ------- | --------------------------- |
| Standard In    | stdin  | 0       | Input from the keyboard     |
| Standard Out   | stdout | 1       | Output to the console       |
| Standard Error | stderr | 2       | Error output to the console |

### 图1.2 预设Unix文件

![](http://ww1.sinaimg.cn/large/76731d17gy1fc6dsa3rr2j20830anq2s.jpg)

这引出了一个问题，***开启的文件***代表着什么。open调用返回的值称为***文件描述符***，本质上是一个开启文件数组的索引，这个数组由内核保持。

### 图1.3 抽象

<span id="abstraction">

![abstraction](http://ww1.sinaimg.cn/large/76731d17gy1fc6e8fmo1sj20o40glq34.jpg)

文件描述符是内核储存的文件描述符表的一个索引。内核创建一个文件描述符作为一个open调用的应答然后将文件描述符与一些下层类文件对象的抽象联系起来，也许那是一个真正的硬件装置，或一个文件系统或者完全是其他玩意儿。因此一个进程的read或write调用表示着文件描述符被内核指引到了正确的位置，最终会做一些有用的事。

简而言之，文件描述符是通向内核对底层硬件抽象的大门。物理设备的抽象概述在[图1.3 "抽象"](#abstraction)中展示了。

从最低层开始，操作系统需要程序员来创造***设备驱动***建立与硬件设备的通讯。这个设备驱动程序是写给由内核提供的API的，就像[例1.2，"在/include/linux/virtio.h中的抽象"](/chapter1/section1.2.html#virto-abstraction)；内核将会调用一系列由驱动程序提供的函数来应答各种请求。在以上精简的例子中，我们可以看到驱动程序提供了一个read和write函数，其将会在应答文件描述符上类似操做时被调用。设备驱动程序知道如何为特定的设备将这些笼统的请求转换成明确的请求或指令。

为了提供用户空间的抽象，内核经由被统称为***设备层***的东西提供文件接口。主机上的物理设备在特别的文件系统中由一个文件表示例如/dev。在类UNIX操作系统中，**设备节点**有一个***主要(major)***和一个***次要(minor)***数，它使得内核能够使他们的底层设备与特定的节点建立联系。这些可以由ls看出如[例1.3，"主要数和次要数的举例"](#example1.3)

<span id="example1.3">

### 例1.3 主要数和次要数的举例 

```bash
 $ ls -l /dev/null /dev/zero /dev/tty
crw-rw-rw- 1 root root 1, 3 Aug 26 13:12 /dev/null
crw-rw-rw- 1 root root 5, 0 Sep  2 15:06 /dev/tty
crw-rw-rw- 1 root root 1, 5 Aug 26 13:12 /dev/zero
```

这将我们的话题带到了文件描述符，其是用户空间用来与底层设备谈话的把手。广义上讲，当一个文件被打开时发生的是，内核使用路径信息映射文件描述符（其带有某些能提供合适read和write等等API的东西）。当这是一个对于设备（/dev/sr0 上面）的open，被打开设备的主要数和次要数提供了内核找到正确设备以及完成映射所需的信息。内核接下来将会知道如何路由后面的调用（例如read）到由设备驱动提供的底层函数。

一个非设备文件以相似的方法运作，虽然之间有更多的层次。这里的抽象是***挂载点（mount point）***；挂载文件系统建立映射有双重目的，使得文件系统知晓提供储存的设备以及使得内核知晓挂载点下的文件应该被指向文件系统驱动。就像设备驱动一样，文件系统被写入了内核提供的特定的通用文件系统API。

现实生活中确实有许多其他层次使得一切变得复杂。例如，内核将会竭尽全力地把经可能多的磁盘中的数据缓存到否则将会空闲的内存中；这提供了许多速度优势。它也会尝试以尽可能高效的方式组织设备存取；例如尝试安排磁盘读取以确保一起物理存储的数据一起检索，即便请求不是按顺序到达的。再有，有许多设备属于更加通用的类别例如USB或SCSI设备，他们提供他们自己的抽象层来写入。因此，文件系统不会直接写入设备，而是穿过许多层次。理解内核就是理解这些API的联系和共存。

## The Shell

Shell是与操作系统交互的门户。它也许是bash，zsh，csh或其他的许多shell。他们本质上都只有一个主要任务——让你能够去执行程序（等之后我们讲到操作系统内部的时候你将会开始认识到shell究竟是怎么做到这些的）。

但是shell能做更多事而不仅仅让你能够执行程序。他们有能够重定向文件的强大能力，使你能够同时执行多个程序以及编写完整的程序。这些都回到了***万物皆文件***这句话。

### 重定向

通常我们不想要在[文件描述符小节](#file-descriptors)中提到的标准文件描述符指向他们预设的地方。例如。你也许想要抓取一个程序的所有输出到一个磁盘上的文件，或者，让它从你之前准备的文件中读取命令。另一个有用的任务可以是将一个程序的输出传到另一个程序的输入。和操作系统相结合，shell使得这一切变得便利得多。

### 表1.2 标准Shell重定向功能

| 名称       | 指令                                    | 描述                                       | 举例                          |
| -------- | :------------------------------------ | ---------------------------------------- | --------------------------- |
| 重定向到一个文件 | `> filename`                          | 讲标准输出的所有输出取出然后放进`filename`。注意，使用`>>` 将会追加到文件，而不是覆写它。 | `ls > filename`             |
| 从一个文件读取  | `< filename`                          | 将文件的所有数据复制到程序的标准输入。                      | `echo < filename`           |
| 管道       | <code>program1 &#124; program2</code> | 获取`program1`标准输出的一切然后传递到`program2`的标准输入  | <code>ls &#124; more</code> |

### pipe的实现

ls | more的实现只是抽象之力量的另一个例子。这里本质上发生的不是将标准输出的文件描述符与一些底层设备相联（比如控制台，对终端输出），而是描述符被指向了一个由内核提供的内存缓冲器，其通常被称为一个***管道(pipe)***。这里的花招是，另一个进程可以将它的标准输入与同一个缓冲器的另一端相连然后能够高效地获取另一个进程的输出。这在[图1.4，"工作中的一个pipe"](#pipe-in-action)中被说明。

### 图1.4 工作中的一个pipe

<span id="pipe-in-action"></span>

![](http://ww1.sinaimg.cn/large/76731d17gy1fc6o9rdcqxj20ni0ao746.jpg)

pipe是将两个进程连接起来的一个内存缓冲器。文件描述符指向一个pipe对象，排空（通过一个read）发送给它（通过一个write）的被缓冲数据。

对pipe的写入会被内核储存直到相对应的另一端的读操作排空缓冲区。这是一个非常~~牛逼~~强大的概念而且这是类UNIX操作系统中***进程间通讯***（aka:IPC）的一种基本形式。pipe不只是允许数据传输；它可以作为一个信号通道。如果一个进程读一个空的pipe，它将被默认阻塞或进入休眠直到有数据可以获取（这将在[第五章，进程](/chapter5/)进行更深层次的探讨）。因此两个进程可以通过仅仅写一个字节的数据在采取某些操作时使用一个pipe进行通信；确切的数据并不太重要，仅仅是任何数据在pipe中存在就可以表示一个信息。举个例子，一个进程要求另一个进程打印一个文件——这会花些时间。这两个进程也许会在他们之间设置一个pipe，请求进程在空pipe上进行一个read；管道是空的，调用阻塞且进程不再继续。一旦打印完成，另一个进程可以把消息写入pipe，这高效地唤起了请求进程并且标志着工作完成。

允许进程在相互间像这样传递数据触发了另一个UNIX格言，小工具只做一件事，把这些小工具链接起来就能获得单一庞大的工具通常不具有的灵活性。