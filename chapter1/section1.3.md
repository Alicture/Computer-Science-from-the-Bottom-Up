# 文件描述符

<span id="file-descriptors">

UNIX程序员首先要知道的就是每个正在运行的程序都始于三个已经打开的文件：

### 表1.1 Unix提供的标准文件

| **表述的名称**      | **缩写** | **文件数** | **描述**                      |
| -------------- | ------ | ------- | --------------------------- |
| Standard In    | stdin  | 0       | Input from the keyboard     |
| Standard Out   | stdout | 1       | Output to the console       |
| Standard Error | stderr | 2       | Error output to the console |

### 图1.2 预设Unix文件

![](http://ww1.sinaimg.cn/large/76731d17gy1fc6dsa3rr2j20830anq2s.jpg)

这引出了一个问题，***开启的文件***代表着什么。open调用返回的值称为***文件描述符***，本质上是一个开启文件数组的索引，这个数组由内核保持。

### 图1.3 抽象

<span id="abstraction">

![abstraction](http://ww1.sinaimg.cn/large/76731d17gy1fc6e8fmo1sj20o40glq34.jpg)

文件描述符是内核储存的文件描述符表的一个索引。内核创建一个文件描述符作为一个open调用的应答然后将文件描述符与一些下层类文件对象的抽象联系起来，也许那是一个真正的硬件装置，或一个文件系统或者完全是其他玩意儿。因此一个进程的read或write调用表示着文件描述符被内核指引到了正确的位置，最终会做一些有用的事。

简而言之，文件描述符是通向内核对底层硬件抽象的大门。物理设备的抽象概述在[图1.3 "抽象"](#abstraction)中展示了。

从最低层开始，操作系统需要程序员来创造***设备驱动***建立与硬件设备的通讯。这个设备驱动程序是写给由内核提供的API的，就像[例1.2，"在/include/linux/virtio.h中的抽象"](/chapter1/section1.2.1.html#virto-abstraction)；内核将会调用一系列由驱动程序提供的函数来应答各种请求。在以上精简的例子中，我们可以看到驱动程序提供了一个read和write函数，其将会在应答文件描述符上类似操做时被调用。设备驱动程序知道如何为特定的设备将这些笼统的请求转换成明确的请求或指令。

为了提供用户空间的抽象，内核经由被统称为***设备层***的东西提供文件接口。主机上的物理设备在特别的文件系统中由一个文件表示例如/dev。在类UNIX操作系统中，**设备节点**有一个***主要(major)***和一个***次要(minor)***数，它使得内核能够使他们的底层设备与特定的节点建立联系。这些可以由ls看出如[例1.3，"主要数和次要数的举例"](#example1.3)

<span id="example1.3">

### 例1.3 主要数和次要数的举例 

```bash
 $ ls -l /dev/null /dev/zero /dev/tty
crw-rw-rw- 1 root root 1, 3 Aug 26 13:12 /dev/null
crw-rw-rw- 1 root root 5, 0 Sep  2 15:06 /dev/tty
crw-rw-rw- 1 root root 1, 5 Aug 26 13:12 /dev/zero
```

这将我们的话题带到了文件描述符，其是用户空间用来与底层设备谈话的把手。广义上讲，当一个文件被打开时发生的是，内核使用路径信息映射文件描述符（其带有某些能提供合适read和write等等API的东西）。当这是一个对于设备（/dev/sr0 上面）的open，被打开设备的主要数和次要数提供了内核找到正确设备以及完成映射所需的信息。内核接下来将会知道如何路由后面的调用（例如read）到由设备驱动提供的底层函数。

一个非设备文件以相似的方法运作，虽然之间有更多的层次。这里的抽象是***挂载点（mount point）***；挂载文件系统建立映射有双重目的，使得文件系统知晓提供储存的设备以及使得内核知晓挂载点下的文件应该被指向文件系统驱动。就像设备驱动一样，文件系统被写入了内核提供的特定的通用文件系统API。

现实生活中确实有许多其他层次使得一切变得复杂。例如，内核将会竭尽全力地把经可能多的磁盘中的数据缓存到否则将会空闲的内存中；这提供了许多速度优势。它也会尝试以尽可能高效的方式组织设备存取；例如尝试安排磁盘读取以确保一起物理存储的数据一起检索，即便请求不是按顺序到达的。再有，有许多设备属于更加通用的类别例如USB或SCSI设备，他们提供他们自己的抽象层来写入。因此，文件系统不会直接写入设备，而是穿过许多层次。理解内核就是理解这些API的联系和共存。
